This section presents Spectrum protocol design starting from a naive approach based on PBFT and gradually addressing the challenges.

\subsection{Strawman Design: PBFTNetwork}\label{subsec:strawman-design}

For simplicity we begin with a notarization protocol based on PBFT, then iteratively refine it into Spectrum.

PBFTNetwork assumes that a group of ${n = 3f + 1}$ trusted nodes has been pre-selected upfront and fixed and at most $f$ of these nodes are byzantine.
At any given time one of these nodes is the \emph{leader}, who observes events on connected blockchains,
batch them and initiate round of notarization within the consensus group.
Remaining members of the consensus group verify the proposed batches by checking the presence of updates on corresponding blockchains.
Upon successful verification each node signs the batch with its secret key and sends the signature to the leader.

Under simplifying assumptions that at most $f$ nodes are byzantine the PBFTNetwork guarantees livness and safety.
However, the assumption of a fixed trusted committee is not realistic for open decentralized systems.
Moreover, as PBFT consensus members authenticate each other via non-transferable symmetric-key MACs, each consensus
member has to communicate with others directly, what results in $O(n^2)$ communication complexity.
Quadratic communication complexity imposes a hard limit on scalability of the system.
Such a design also scales poorly in terms of adding support for more chains.
The workload of each validator grows lineary with each added chain.

In the subsequent sections we address these limitations in four steps:
\begin{enumerate}
    \item \textbf{Opening consensus group and leaders.} We introduce a lottery-based mechanism for selecting consensus group and leaders dynamically.
    \item \textbf{Replacing MACs by Digital Signatures.} We replace MACs by digital signatures to make authentication transferable
    and thus opening the door for sparser communication patterns that can help to reduce the communication complexity.
    \item \textbf{Scalable Collective Signature Aggregation.} We utilize Byzantine-tolerant aggregation protocol that allows for
    quick aggregation of cryptographic signatures to reduce communication complexity to $O(\log n)$.
    \item \textbf{Eliminating Validator Bottleneck.} We shard consensus groups into units by the type of chain each node is able to handle.
\end{enumerate}

\subsection{Opening Consensus Group}\label{subsec:opening-consensus-group-and-leaders}
\input{opening-consensus-group}

\subsection{Replacing MACs by Digital Signatures}\label{subsec:replacing-macs-by-digital-signatures}

todo

\subsection{Scalable Collective Signature Aggregation}\label{subsec:scalable-collective-signature-aggregation}

todo

\subsection{Eliminating Validator Bottleneck}\label{subsec:eliminating-validator-bottleneck}

So far each member of consensus group had to track changes on all connected chains in order to participate in consensus properly.

\textbf{Observation 1:} Events coming from independent systems $S_k$ are not serialized.
Thus, the process of events notarisation can be parallelized.

\textbf{Observation 2:} Outbound transactions on independent systems $S_k$ can be independently signed.

Utilizing those properties we now introduce committee sharding.
We modify protocol in a way such that at each epoch $e$ $M$ distinct committees consisting of nodes equipped with functionality unit $F_{S_k}$ relevant to a specific connected chain $S_k$ are selected in a way described in (5.2.2).
All primitives and source of randomness are equal to different committees, the only difference is in the $f$ parameter of $\phi(\alpha_i, f)$ function, which is unique for every connected blockchain in order to guaranty expected number of members in every committee.
We denote one such committee shard as $V^{e}_{S_k}$, which uniquely maps to $S_k$.
Then, complete mapping of committees to chains at epoch $e$ can be represented as a set of tuples commettee-chain $\{(V^{e}_{S_k}, S_k)\}$.
Throughout epoch $e$ all events and on-chain transactions on $S_k$ are handled exclusively by $V^{e}_{S_k}$.

Nodes in $V^{e}_{S_k}$ maintain a robust local ledger $L^{local}_k$ of notarized batches of events observed in $S_k$.

\subsubsection{Syncing Shards}

Notarized batches of events from local ledgers $\{L_i\}_{i=1}^{i=N}$ then should be synced in a super ledger $L^+$ in order for the system to be able to compute cross-chain state transition.
To facilitate this process batches of notarized events are broadcast to other committees.
The main actors at this stage are:
\begin{itemize}
    \item \textbf{Local leaders}: committees leaders, holding local notarized batches.
    \item \textbf{Relayers}: any protocol participant, who broadcasts notarized batches from \emph{Local leaders} to other committees' members.
    Every \emph{Local leader} can be a \emph{Relayer} at the same time.
    \item \textbf{General leader}: one of the \emph{Local leaders} who added a block consisted of all collected notarized batches to the $L^+$.
\end{itemize}

Since any \emph{Local leader} is able to publish his block to $L^+$ he can choose from two main strategies:
\begin{itemize}
    \item \textbf{Wait}: malicious strategy where \emph{Local leader} waits for broadcasts from other committees members and don't broadcast his own batch to eliminate competitors for adding a block.
    \item \textbf{Broadcast and wait}: fair strategy where \emph{Local leader} immediately broadcasts his batch, waits for broadcasts from committees members and honestly competes for adding a block.
\end{itemize}
Thus, there should be a motivation for individual \emph{Local leader} to choose the fair strategy instead of keeping his batch for too long.
This is achieved through the design of the incentive system.

There are three types of incentive: ${\{R_b, R_d, R_m\}}$, where $R_b$ is a guaranteed reward for adding a notarized batch to the block, $R_d$ is given for a broadcasting batch to the general leader and $R_m$ is given personally to the \emph{General leader} who mined the block.
Delivery reward $R_d$ is given to the \emph{Relayer} if and only if a delivery was made within a predetermined period of time $\Delta t_d$.
From the game-theoretic analysis, the following relationships between rewards were derived: ${R_b = 2 \cdot R_d, R_m = 3 \cdot R_d}$.
Thus, if ${R_d=0}$ there is no prior strategy for the \emph{Local leaders}, they will or wait for other batches either broadcast their batches with equal probability.
In case when ${R_d>0}$ it is distributed between the \emph{Local leader} and the \emph{Relayer}, i.e. ${R^l_d = \xi \cdot R_d}$ and  ${R^r_d = (1 - \xi) \cdot R_d}$, where ${\xi \in (0, 1)}$.
While ${\xi \rightarrow 1}$ probability that all \emph{Local leaders} will choose the \emph{Broadcast and wait} strategy approaches $1$.

As a result, the syncing Shards flow looks as follows:
\begin{itemize}
    \item Every \emph{Local leader} broadcasts (himself or through an intermediary as a \emph{Relayer}) his batch $b_i$, which contains the local notarization time $t^N_i$ and waits for batches from other \emph{Local leaders}.
    \item When waiting time approaches $\Delta t_d$, \emph{Local leader} forms a block from all collected batches ${\{b_i^j\}_{j=1}^{j=K}, K \le N}$ and add it to $L^+$.
    Block contains the set of the notarization times $\{t^{N^j}_i\}_{j=1}^{j=K}$ and block creation time $t^B_s$.
    \item After block is settled, all associated actors receive their rewards according to their roles: \emph{General leader} receives $R_m$, \emph{Local leaders}, whose batches are in the block receives $R_b$.
    In addition, if ${t^B_s - t^N_i^* < \Delta t_d}$, where $t^N_i^*$ is $t^N_i$ time, normalized to $L^+$ time, $i$-th committee \emph{Local leader} receives $R_d$ reward shared with the \emph{Relayer}.
\end{itemize}

\subsection{Forks and integrity}\label{subsec:resolving-forks}
\input{forks-and-integrity.tex}

\subsection{Protocol Flow}\label{subsec:protocol-flow}

\subsubsection{Bootstrapping}\label{subsubsec:bootstrapping}

The system is bootstrapped in a trusted way.
A manually picked set of validators $V_0$ is assigned to the first epoch $e_0$.
On-chain vaults are initialized with an aggregated public key $aPK_0$ of the initial committee.
All initial committee members generate verification tuples ${(v_i^{vrf}, v_i^{kes}, v_i^{dsig})}$
and agree on the genesis block.

\subsubsection{Normal Flow}\label{subsubsec:normal-flow}

\begin{enumerate}
    \item Registration.
    All Spectrum stakeholders can register for becoming a committee member.
    To get a chance of becoming a member of $V_n$ in the epoch $e_n$ they register in a lottery during the $e_{n-2}$
    epoch by publishing their verification tuples ${(v_i^{vrf}, v_i^{kes}, v_i^{dsig})}$.
    \item Lottery.
    Once registration is done and epoch $e_{n-1}$ comes to the end, all registered participants evaluates
    ${\mathcal_{F}}_{VRF}$ locally and compare the generated random $y$ with their corresponding consensus threshold
    ${T_i^j}^*$ for this epoch.
    If successful, then publish $y$ and the associated proofs to form an approved consensus members table.
    \item Committee key aggregation.
    Once new committee is selected, nodes in $V_n$ aggregate their individual public keys $\{PK_i\}$ into
    a joint one $aPK_n$.
    \item Committee transition.
    Nodes in $V_{n-1}$ publish cross-chain message ${M_n : (aPK_n, \sigma_{n-1})}$ , where $aPK_n$ is
    an aggregated public key of the new committee $V_n$ , $\sigma_{n-1}$ is an aggregated signature of
    $M_n$ such that ${Verify(\sigma_{n-1}, aPK_{n-1}, Mn) = 1}$.
    Vaults are updated such that ${Vault\{(E_{n-1}, aPK_{n-1})\} \coloneqq (e_n, aPK_n)}$.
    \item Decentralized Asset Management (Custodial).
    Nodes in $V_n$ observe events on supported L1 chains, agree on the set of updates
    and compute state outbound state transitions accordingly.
    \item Notarisation (Non-custodial).
    Nodes in $V_n$ observe events on supported L1 chains, batch updates, collectively sign them and
    publish on-chain.
\end{enumerate}